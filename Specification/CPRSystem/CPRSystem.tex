\documentclass{article}
\usepackage{../../myPackage}


\begin{document}
%start of iteration 1
\pagebreak
	\subsection{CPR System}
		\subsubsection{Iteration 1 - Basic Functionality}
			\paragraph{Aims}
			This iteration develops the core functionality of the CPR system; it is intended to be the simplest application possible that has the required functionality. Subsequent iterations will refine and build on top of its services and components.\\

At its most basic level, the system needs to be able to send a message to a responder’s devices to notify them of the location of an emergency. This individual should be the closest person in the database to the incident. They are then expected to attend the emergency location and provide assistance where necessary. The individual is assumed to have the appropriate qualifications and training which has been verified, and have willingly signed up for the service.\\

	\paragraph{Storyboard}
	This is a storyboard to help visualise the intended functionality of the system.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration1/Storyboard - Iteration 0 - 1"}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration1/Storyboard - Iteration 0 - 2"}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration1/Storyboard - Iteration 0 - 3"}
	\end{figure}
	\begin{enumerate}
  		\item The emergency services receive a call detailing a medical emergency which is triaged.
  		\item While waiting for a response vehicle to arrive, the dispatcher has the option to send the emergency location to a trained responder (first aid or CPR) who may be able to attend quicker than the emergency services. This option to request this responders assistance should be limited to certain situations and locations so that responders are not sent to potentially dangerous environments.
  		\item Once the request has been sent, the responder is notified that an emergency requires their presence. The notification shows the responder the location of the incident
  		\item The responder then decides if they are able to attend the emergency to help the situation and makes their own way there.
	\end{enumerate}
	In theory, the responder gets to the location quicker than an emergency response and they are able to provide first aid to those who need it until the ambulance arrives.\\
	\paragraph{Sending Notifications}
	In order for responders to attend an emergency, they need to know where it is. The standard way of doing this is to send a latitude and longitude, which we will include in the payload section of a GCM message. This information can be directly passed to all mapping applications to plot the location. The structure of the message data should be as follows:
	\begin{lstlisting}
...
"data":
      {
          "message_type":"new_emergency",
          "longitude":"VALUE",
          "latitude":"VALUE"
      }
...
	\end{lstlisting}
In this message the \texttt{\color{OliveGreen}"message\_type"} field describes what kind of message this is. To send a new emergency to the user the value of this field should be \texttt{\color{OliveGreen}"new\_emergency"}. This is checked when the message is received and the appropriate action is taken (i.e. a new emergency alert is created). The alternative is \texttt{\color{OliveGreen}"close\_emergency"} as the value and this is used when the dispatcher wishes to cancel the assistance of the user either because they are no longer required or the casualty has been dealt with and the emergency case closed (see ‘App CPR pane’ for more details). \\

The other data we need to send is a coordinate pair corresponding to the location of the emergency, (where longitude and latitude values are in the range of [-180, 180] and [-90, 90] respectively [16]) as this is a standard way of referencing a location and is the coordinate system major map applications use. This will allow us to parse the coordinates directly into a map app on the device to show the user where to go. This can be easily done in two ways, one is opening the default maps app with the location entered into a geo-URI [17] and opening it. This URI contains the coordinates and when called opens the default map with the location shown as a drop point (Example: \texttt{\color{OliveGreen}"geo:0,0?q=34.99,-106.61(Emergency)"}). The second option is to incorporate the Maps API into our app, this would allows us a greater degree of control on what the user can see and also disable features (such as removing the emergency marker). The implementation of this is relatively easy and adding a marker simply uses the \texttt{\color{OliveGreen}LatLng} data type [18].
\lstset{language=Java}
\begin{lstlisting}
public void onMapReady(GoogleMap map) {
    map.addMarker(new MarkerOptions()
        .position(new LatLng(10, 10))
        .title("Emergency"));
}
\end{lstlisting}
\lstset{language=XML}
Integrating a map into our app is the route we have decided to go down as this allows us greater granularity and control over what the user sees and is able to do. This should be shown to the user when they click on an emergency notification.\\

\paragraph{Notification Interaction and Alert}
When an emergency is sent to the phone the user will need to be notified immediately so that they can attend the scene as quickly as possible. The first step towards doing this is to create a popup notification so that the user can immediately see (either on top of other applications or on the lock screen) that their assistance is required.\\

There are two main factors of information that the user needs to be informed of, the first is that their assistance is required, the presence of this notification does imply this however it should also be stated somewhere in the notification that this is an emergency situation. The second is the location of the emergency, for this we have identified two main points of information that are useful to the user. The first is the address of the emergency location, this should be present so that if the user knows the area around them they can instantly recognise where they are needed and start making their way towards it. It also allows them to give directions, say to a taxi driver, directly from the notification without having to open the app at all. The second is the distance to the emergency that the user is currently This information is very useful to the user as it allows them to instantly gauge how long they will take to attend the scene and make decisions based off this such as the best mode of transport.\\

To provide both of these points to the user we will need to use Android’s built-in location API, as the information provided to the device is in coordinate form. There are several features which will allow us to obtain the required information, the first is in the Geocoder class of the location API [19]. The method \texttt{\color{OliveGreen}getFromLocation()} rmation, the first is in the Geocoder class of the location API [19]. The method getFromLocation()takes a coordinate pair (latitude and longitude) and returns a list of addresses which are known to describe the area immediately surrounding the coordinates. Upon calling this we can then extract the address line by line using the associated methods with the \texttt{\color{OliveGreen}Address} class [20] and insert them into our notification. We can also use the \texttt{\color{OliveGreen}Location} class of the location API to get the \texttt{\color{OliveGreen}distanceTo()} a destination [21]. This takes a location as a parameter (which we can set the longitude and latitude of) and returns the distance in meters to the destination from the users current location.\\

\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{center}
    \includegraphics[width=0.48\textwidth]{"Iteration1/Android Notification Layout"}
  \end{center}
\end{wrapfigure}
Android supports a variety of notification formats [22] however they all have four common features, a Title/Name, Notification Icon, Timestamp and a Message. Our notification should also have these features, the title should be a common one (for all emergency notifications) which relates to the fact that the users assistance is required at an emergency. A title similar to “Medical Assistance Required” should both inform the user of what the notification is for and grab their attention. \\

\begin{wrapfigure}{l}{0.15\textwidth}
  \begin{center}
  \vspace{-20pt}
    \includegraphics[width=0.15\textwidth]{"Iteration1/Android notification icon"}
  \vspace{-30pt}
  \end{center}
\end{wrapfigure}
The notification icon should also be striking to grab their attention, and also needs to be unique to the app and tell the user, at a glance, the nature of the notification. Something similar to this image would be best as the image is striking and so should catch the users attention while being unique among other notification icons and being related to the theme of the notification. \\


\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{center}
  \vspace{-20pt}
    \includegraphics[width=0.48\textwidth]{"Iteration1/Android Notification Layout Extended"}
  \end{center}
\end{wrapfigure}
The timestamp of the notification should be set to the time that the push notification was received and the message body should contain both the distance to and the address of the emergency. Android allows “expandable layouts” [22] which allows the notification to be minimal initially and expand when clicked on. The minimal layout still contains both the title and the icon (along with a line of text) which means the user can still instantly see what the notification is about and can click on it to expand the description (which contains the address).\\

\begin{wrapfigure}{l}{0.5\textwidth}
  \begin{center}
  \vspace{-20pt}
		\includegraphics[width=0.5\textwidth]{"Iteration1/Android Notification Design"}  \end{center}
\end{wrapfigure}
	This is a design shown how our notification might look to the user on either the lock screen or while actively using the phone. Upon clicking this notification the app will be launched and show a ‘CPR pane’ which would not be normally accessible. This pane contains a map with the location of the emergency shown clearly with a marker, the users current location and a directions button which will plot a route to the emergency from the users current location.\\
	
	\pagebreak
	\paragraph{Cancel Notification}
	The dispatchers should also be able to cancel the assistance request remotely for a variety of reasons such as the emergency has been dealt with or paramedics have already arrived to name a few. To do this we will utilise the collapsible feature of messages sent over GCM [23] which allows us to overwrite previous messages with the same \texttt{\color{OliveGreen}“collapse\_key”}. We can combine this with the field in the payload of the message \texttt{\color{OliveGreen}"message\_type"} which is set to \texttt{\color{OliveGreen}"new\_emergency"} when the dispatcher wishes to ask for assistance. The new message should have a  \texttt{\color{OliveGreen}"message\_type":"close\_emergency"} so that, when the message is read the message type should be checked and the appropriate action taken, in this case it should, if its currently accessible, hide the CPR pane and clear any associated data. A message field should also be present which will be displayed in the message field of the notification.
	\begin{lstlisting}
...
"data":
      {
          "message_type":"close_emergency",
          "message":"Emergency resolved"
      }
...
	\end{lstlisting}
	
	\paragraph{Notification Sound of the App}
	This was the first thing which we thought the user would like to customize as this has been  commonplace among phones for years and our users would expect to be able to do this with our app. However, after some discussion we thought about how this might negatively affect the user’s ability to be alerted to incoming emergencies. For example, if a user was allowed to set their own notification sounds and they chose one that was the same (or similar) to their message alert or ringtone then they might be more inclined to ignore the phone for a period of time believing it was just a regular notification. This is more likely as our app is likely to be only used occasionally when the individual is the closest responder to an emergency, it will be a case of ‘setup and forget’ for most users who might even have forgotten they installed it until they are being asked to help.\\

For this reason we have decided against allowing the user to change the notification sounds. We intend to use a custom alert noise which is unlike any other provided by default on the phone. We believe that keeping this sound is more beneficial than allowing the user more personalisation as they will not recognise the sound and therefore are more likely to check why their phone is making a noise.\\

\pagebreak
\paragraph{CPR App Pane}
This is the design prototype for the CPR pane of the application. By default (i.e if its opened without an emergency) this shows a blank map and information pane which, when an emergency notification is received from the dispatchers, changes to display the information for that emergency. Upon receiving the notification (with the payload data) the coordinates are sent to this app and become the destination marker of the map.\\

\begin{wrapfigure}{l}{0.4\textwidth}
  \begin{center}
		\includegraphics[width=0.4\textwidth]{"Iteration1/Android CPR app pane"}  \end{center}
\end{wrapfigure}
The associated information is displayed at the bottom third of the pane which can be obtained (as in the ‘Notification Interaction and Alert’ section) from coordinates provided using the location API. The distance measurement should be re-calculated at a set interval so that the value is updated while moving.\\

The map also contains a ‘Directions’ button which, when pressed, will start navigation assistance from the users current location to the emergency.\\

We have decided to implement an in-app map view rather than opening the directions in the default map app because it gives us a greater degree of control over what we can show the user and allow them to interact with. For example it allows us to disable the ‘draggable’ state of the marker [18] so that the user cannot accidentally move it to the wrong location and then delay their response time. It also allows us to display our own content on the screen (in the lower third) at the same time that the user is getting directions to the emergency. This is currently displaying the address and distance of the emergency from the user however it could be used to display extra information as appropriate.\\

There are two ways for this information to be hidden once again. The first is that the phone receives a new notification from the dispatchers which contains the same \texttt{\color{OliveGreen}“collapse\_key”} as this emergency (detailed in ‘Cancel Notification’) in this case it should clear any associated data from the app (the destination marker and info pane). The second way is when the app is first loaded a timeout timer should be started which contains a reasonable amount of time to allow the user to attend the scene, but once expired should hide this pane from view and clear any previous emergency data. A timer of 60 minutes should be enough time for any first responder to attend a scene and pass the casualty over to the emergency services (this time should in fact be more than enough). This is so that if, for some reason, the collapse message is not received the information will be removed on its own accord\\

\paragraph{GPS Location}
We need to maintain a database of registered users locations so that we can target an individual who is the closest person to the emergency and send a notification directly to them via GCM. There are a number of ways which we could implement this, however we decided to (for this iteration) push the location from the device to our servers on a regular time interval. A time period of 1 hour is what we will use initially, this should be enough to maintain a reasonably accurate location of the user (more accurate when they are stationary for a while and less accurate while traveling) while not heavily impacting battery useage or performance of the device with more frequent updates. While not being a very complex or clever system this will be enough for us to get started and will be sufficient for this iteration.\\

An alternative implementation would have been to push the location of all emergencies to all phones registered on the service. It would then be upto the phone to determine if they were close enough to alert the user to the emergency. We decided against this method for a few reasons, firstly it does not scale well with a large user base. If this was to be rolled out nationally you could easily be sending hundreds of emergencies to thousands of phones on a daily basis. This would also drastically affect battery life of the users device as it would then have to process each emergency received to determine if it was near them, possibly leading to increased user dissatisfaction and uninstallations of the app. Finally, there would be a lot more data being sent and received in this implementation. Rather than sending each clients location once every 1 hour (for example) you would have to send each emergency to every registered phone which would quickly rack up with multiple emergencies per day.\\

Other ideas we thought about were having the user subscribe to an area that they are likely to be in (possibly one for work and home) then using this location to send messages to people who are likely to be in the area. This is currently how the Swedish project “Project SMS-livräddare“ [6] is contacting its users. We feel however, that this is not accurate enough as there will be situations when they are not around the area (e.g traveling to another city) and using the GPS location of the phone would allow us to contact users with greater geographically accuracy. \\

To send this data to our server we decided to use GCM’s upstream message feature to send the message via Google’s CCM (Cloud Connection Service). We chose this over establishing our own connection for a few reasons but primarily for increased efficiency. GCM upstream messages are sent over the same connection used for receiving, which is managed by the operating system and is left in an ‘always open’ state. It makes sense to utilize this connection rather than use excess resources which would decrease performance (such as battery) [26]. It is also very easily implemented as the API provided does most of the work that would have to be managed if we were to implement our own connection (e.g. checking if the network is available) [27]. It is also not necessary to establish our own connection as the only data we will be sending to the server (in this iteration) is a GPS coordinate pair for the users location, this can be easily converted into string format and sent as a payload GCM message.\\

The message should be sent according to the specification detailed in the GCM justification section under ‘Sending Upstream Messages’. This details that the sent message will have the users registration ID attached which the server can use to associate this sent location with a registered user. The structure of the message data should be as follows:
\begin{lstlisting}
...
"data":
      {
          "message_type":"location_update",
          "longitude":"VALUE",
          "latitude":"VALUE"
      }
...
\end{lstlisting}
This message, when received by our server, will then be able to parse the message type to see that it is a new location that's being sent and add it to the database appropriately. The longitude and latitude values are the devices current location and can be obtained by the ‘getLastLocaiton()’ method of the Location API [28]. Android's Network Location Provider determines user location using cell tower and Wi-Fi signals, providing location information in a way that works indoors and outdoors, responds faster, and uses less battery power. This method returns the most recent location currently available, if another app has recently updated the devices location then this will be used otherwise it will be updated before the most recent value is returned.\\

\paragraph{Database Design}
The simplicity of this iteration means that it does not require a complex database. We fully intend to have to make sweeping changes to this design in future iterations, however it should form an easily-expandable base on which to build.\\

The DBMS used for this system will be Microsoft SQL Server 2014, due to its prevalence in professional applications, spatial data types and comprehensive high-availability features, including redundancy and failover, which are critical for a system as important as this.\\

	\subparagraph{Requirements}
	\begin{itemize}
	\item \textit{Registration details of responders}\\
This need only be a unique identifier and forename and surname for now - it can be trivially expanded later on, so we will not dwell on implementation details.
	\item \textit{Responders’ devices}\\Each responder can (and should) register as many devices as they have to their account, in order to increase the chances of them being successfully notified that their assistance is required. In order to do this, we need to store information about responders’ devices, in particular the push notification key that allows us to tell GCM (or any alternate service, such as APNS) which device to send notifications to.
	\item \textit{The locations of these devices at any given time}\\To be able to find the closest responder to the incident, we need to track the locations of all responders’ devices in as close to real-time as possible. We could only keep the latest position, however maintaining the full history (or at least a certain amount of it) is a trivial change, and could be used in the future to improve the responder selection algorithm.
	\item \textit{Incidents, and the responder chosen to attend that incident}\\The database needs to be able to store the location of incidents so it can send these to responders. It must also keep a history of which responder attended which incidents for logging purposes.
	\end{itemize}
	
	\subparagraph{Data Types}
	Location data is commonly represented as a latitude and longitude pair, however modern databases have dedicated spatial data types. SQL Server 2014 is no exception; it has the \texttt{\color{OliveGreen}geography} type for ellipsoidal data. The key \texttt{\color{OliveGreen}geography} instance type that we’ll be using is \texttt{\color{OliveGreen}Point}: a 0-dimensional object representing a single location. We’ll use it to identify the whereabouts of incidents and responders’ devices. It has the added benefit of supporting elevation, should we need it in the future to increase accuracy of location data.\\
	
	Primary keys will be \texttt{\color{OliveGreen}ints}, unless we can guarantee they will not overflow if a smaller width type is used. Unfortunately SQL Server only supports signed types, so 32-bit integers will allow up to 2,147,483,647 (231 - 1) rows per table. Considering there are roughly 65m people in the UK, this is more than enough to store all possible responders. Even at this limit, the type is large enough to handle each of them having 33 registered devices each - also an infeasible number. As already mentioned, there are an estimated 60,000 [2] incidents in the UK every year that this system could be relevant to. Assuming this figure doesn’t exceed, an \texttt{\color{OliveGreen}int} primary key will sustain the system for 35 millenia. The only exception is device types: there are less than 255 services offering push notification facilities, so a \texttt{\color{OliveGreen}tinyint} will suffice for this purpose.\\

Device keys are allowed to be up to 4096 bytes, as GCM \texttt{\color{OliveGreen}registration\_ids} can be up to 4KB in size, however in practice they will be much smaller than this - it is this long to handle edge cases.\\

\pagebreak
\subparagraph{Entity Relationship Diagram}
Entity relationship diagram of the database.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration1/cpr-database-0"}
	\end{figure}

N.B. \texttt{\color{OliveGreen}Incidents.ResponderID} is nullable as it is conceivable that an incident might be created, and it take a few moments for a responder to be assigned to it.\\

\paragraph{Selecting the Responder to notify}
In this iteration, we are simply choosing the single closest responder to the incident. In terms of the above schema, we need to alert the owner of the device whose latest position is closest to the incident.\\

We have a table of device locations; the first step is to extract the latest location of each device:
\lstset{language=SQL}
\begin{lstlisting}
SELECT LatestLocations.DeviceID, LatestLocations.Location
FROM (SELECT DeviceLocations.DeviceID, DeviceLocations.Location,
             ROW_NUMBER() OVER (PARTITION BY Devices.DeviceID
                                ORDER BY DeviceLocations.Timestamp DESC) AS Rank
      FROM Devices
	      INNER JOIN DeviceLocations
	          ON DeviceLocations.DeviceID = Devices.DeviceID
	 ) AS LatestLocations
WHERE LatestLocations.Rank = 1
\end{lstlisting}
\lstset{language=XML}
As well as spatial data types, SQL Server also includes operations on these types, one of which is \texttt{\color{OliveGreen}STDistance}, which returns the shortest distance between two \texttt{\color{OliveGreen}Point}s. We can now intersect this with the known location of the incident, producing a list of \texttt{\color{OliveGreen}DeviceID}s in ascending order of distance to the incident.
\lstset{language=SQL}
\begin{lstlisting}
-- will hold the location of the incident
DECLARE @incident geography;

-- look up the location of the incident with identity `x`
SELECT @incident = Location FROM Incidents WHERE IncidentID = x;

-- sort devices by their proximity to the location of the incident
SELECT LatestLocations.DeviceID,
       LatestLocations.Location,
       @incident.STDistance(LatestLocations.Location) AS Proximity
FROM (SELECT DeviceLocations.DeviceID, DeviceLocations.Location,
             ROW_NUMBER() OVER (PARTITION BY Devices.DeviceID
			            ORDER BY DeviceLocations.Timestamp DESC) AS Rank
      FROM Devices
	      INNER JOIN DeviceLocations
	          ON DeviceLocations.DeviceID = Devices.DeviceID
	 ) AS LatestLocations
WHERE LatestLocations.Rank = 1
ORDER BY Proximity ASC;
\end{lstlisting}
\lstset{language=XML}
From here, it is trivial to look up the owner of the closest device and notify all of their devices of the emergency.\\


%start of iteraitoin 2
\pagebreak
		\subsubsection{Iteration 2 - Accept \& Decline an emergency}
		\paragraph{Aim}
		This iteration addresses the issue of an individual either not being able to attend an emergency or not responding to the emergency request in a reasonable time. It will also address whether the person contacted is unreachable and how the system should react in that situation.\\
		
On completion, this iteration should give responders the choice to either accept or decline a request for attendance at an incident, and depending on their decision, the system should be able to react appropriately. It should also address the issue of the contacted user being unreachable after the system sends a help request notification.\\

		\paragraph{Storyboard}
		This storyboard visualises the intended functionality of the system.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration2/Storyboard - Iteration 1 - 1"}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration2/Storyboard - Iteration 1 - 2"}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration2/Storyboard - Iteration 1 - 3"}
	\end{figure}
	\begin{enumerate}
  		\item The closest person to the emergency is contacted (as per the previous iteration).
  		\item They are now given the opportunity to accept or decline the request.
  		\item If they accept the request, they go off to help at the emergency. If they decline, the system contacts the next closest person to the emergency. Subsequent responders are also given the option to accept or decline.
  		\item This continues until a user says they are able to help or the request is cancelled/resolved by the dispatcher.
	\end{enumerate}
	This will make our system more robust as we are no longer assuming that the first person contacted can attend the incident. It also gives responders more control over when they can help rather than simply being contacted and their attendance assumed (as in the previous iteration). This reflects a much more realistic use case, as in reality responders will be busy, or their devices will be unavailable, or notifications will be delayed.\\
		
		\pagebreak
	\paragraph{Confirming Attendance}
	The best way for us to allow the user to tell the server if they intend to respond to an emergency help request is through  Accept and Decline buttons. This presents the choice to responders in an obvious way that requires no training or learning time.\\
\begin{wrapfigure}{l}{0.4\textwidth}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{"Iteration2/Iteration 1 - Accept_Decline Buttons 1"}
  \end{center}
\end{wrapfigure}
	
These buttons should be present in the app rather than the notification as then responders are able to see more information about the emergency (such as its the location on a map) before making their decision. It is also less likely to be miss-tapped, as the user first has to acknowledge the notification and open the app to be able to respond.\\

This prototype demonstrates the button placement of the Accept and Decline buttons. They have taken the place of the ‘directions’ button (which started route guidance to the emergency), as this is not applicable until the user has indicated they are attending the incident. In addition, this placement does not interfere with any other visual elements; all information is still readable and clear.\\

The Accept and Decline button colours should be red and green respectively to fit in with the standard format for Yes/No buttons, and to encourage responders to accept requests for help. The placement of the Accept button should be to the left, as this makes it harder to mis-tap - the majority of the population are right handed, [29] and this positioning requires more of a stretch to reach.\\

We have also decided to implement a background timeout for the user to acknowledge a notification. This should start when an emergency request is sent from our server (via GCM) and the notification is displayed. The user will then have 30 seconds to open the notification before the timeout kicks in. If the user does not respond within this time, the notification is automatically declined and the server will send the notification to the next closest person as if the user had declined it themselves.\\

This is implemented because of the time sensitive nature of these type of emergencies. The idea of the first responder is to be able to attend the scene before the emergency services can get there (the target response time being 8 minutes[30]), so any delay in alerting a potential first responder reduces their usefulness. As a result, if the first person contacted does not reply quickly enough then our system will discard them and move onto the next person who might be able to help faster.\\

This cycles should continue until one of the following conditions has been met:
\begin{itemize}
\item The 8 minute average response time has passed, after which we expect an emergency response to be either at the incident or very close. After this time the likelihood of a first responder being able to help the injured individual has also decreased dramatically, to the point where it is highly unlikely they would be able to do anything.
\item The next individual who is due to be contacted with the emergency is beyond the reasonable response distance for a first responder. This stops the chain of help requests reaching anyone who is too far away to be able to help. This distance should be based off the time it would take an individual to travel to the incident. On average an 8 minute journey would take the traveller around 2-3 miles in an urban environment, and up to 5-6 miles in a more rural setting. Therefore our cut-off distance should be towards the upper end to allow people in rural areas the chance to attend the incident. Around 5 miles should be appropriate.
\end{itemize}
We cannot use the state of the emergency as a cut-off for our system, as emergency responses tend to not report on the status of their emergency until the casualty has been delivered to a hospital. If we were to use this then our system would still be sending first responders to the emergency after the ambulance had left, wasting their time and reducing the likelihood of them continuing to use the system.\\

\paragraph{Confirmation Messages}
\begin{wrapfigure}{r}{0.4\textwidth}
  \begin{center}
  \vspace{-30pt}
    \includegraphics[width=0.4\textwidth]{"Iteration2/Iteration 1 - Accept_Decline Buttons 2"}
  \end{center}
  \vspace{-140pt}
\end{wrapfigure}
The Accept and Decline buttons should also have a verification message box to ensure the user intended to select that option. This should clearly state the action (accept or decline)  and  be placed on the screen so that the bottom information pane is still visible.\\

Finally, upon the user accepting an incident, the app pane should have a Withdraw button still visible for cases where there was a missclick (even after the verification), or a situation arises where the user is unable to attend (such as unforeseen traffic jam). Upon clicking this button the system should resume as if it were a normal decline, and alert the next user if the end criteria have not been met.
\pagebreak

\begin{wrapfigure}{l}{0.55\textwidth}
  \begin{center}
  \vspace{-30pt}
    \includegraphics[width=0.55\textwidth]{"Iteration2/Iteration 1 - Accept_Decline Buttons 3"}
  \end{center}
  \vspace{-250pt}
\end{wrapfigure}


This button should be placed on the left hand side of the screen for the aforementioned reasons, and be next to the Directions button so that it does not interfere with any of the information being displayed to the user.\\

Upon clicking this button, the user should be presented with a confirmation screen which clearly states what the action they are performing means.\\

\pagebreak
\paragraph{Keep playing alert sound until user accepts/declines}
This is another feature of the app which we discussed and decided on what to implement. Should the phone play a single notification sound or for the sound to keep playing (like an incoming call) until the user accepts or declines it. We decided to play a continuous alert until the user begins to actively use the phone, this means that the alert will play until the phone is turned on (from sleep state), the volume buttons are pressed (standard way to mute an alert on most devices) or the user accepts or declines the emergency alert.\\

This can be easily implemented as we are able to run any code which we like upon receiving a GCM message for this app. This will allow us to start the alert tone and add hooks into the various stop events which will cancel the playing of the alert.\\

\paragraph{Database Modifications}
This iteration requires the ability to link multiple responders to an incident, which necessitates several changes to the database design. The first step is to remove the \texttt{\color{OliveGreen}ResponderID} field from the \texttt{\color{OliveGreen}Incidents} table, as the relationship is now too complex to be implemented in this way. Instead, another table of \texttt{\color{OliveGreen}IncidentResponders} is needed, which had a foreign key into \texttt{\color{OliveGreen}Incidents:}	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.87\textwidth]{"Iteration2/cpr-database-1"}
	\end{figure}
	
	This allows us to keep track of multiple responders attending a single incident, each having an \texttt{\color{OliveGreen}IncidentResponderID}, which uniquely identifies a responder attending an incident.\\

Next, we need to be able to keep track of the status of each responder - effectively the progress of their notification, from sent, to accepted, declined or withdrawn, including no response at all. This information requires another table, which shall be called \texttt{\color{OliveGreen}IncidentResponderEvents:}\\	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration2/cpr-database-2-portrait"}
	\end{figure}
	
	In the schema above, when a responder is selected to attend an incident, a row is inserted into \texttt{\color{OliveGreen}IncidentResponders}, and notifications for their devices queued for sending. When this completes, a row is inserted into \texttt{\color{OliveGreen}IncidentResponderEvents} with status ‘sent’. From this point on, the aforementioned timeout for the responder to indicate whether they will be attending the incident starts. This timeout should be implemented in the application layer.\\

When the responder selects ‘accept’ or ‘decline’, the application will insert a new row into\\
\texttt{\color{OliveGreen}IncidentResponderEvents} with the corresponding status, and similarly for if a responder withdraws their acceptance. If that status was ‘declined’ or ‘withdrawn’, the application must first check the timeout for responder help has not expired, before repeating responder selection, which takes into account declined responders for an incident, making sure they are not selected again. More about this process is detailed in the next section.\\

\paragraph{Selection Algorithm Modifications}
This iteration requires selection of the ‘next best’ responder, which the previous algorithm could not cope with. However, the change is not a difficult one. Given the above database modifications, it is easy to take the set of responders who have declined or withdrawn from a given incident, and subtract this from the set of all potential responders who could attend, removing their devices from the selection step.\\

Similarly, introducing a maximum distance, above which devices (and therefore responders) are ignored is straightforward. SQL Server’s \texttt{\color{OliveGreen}STDistance} function returns a distance in metres, so a conversion into miles can be done by dividing the returned value by 1609.344. Armed with this information, it’s simply a case of adding another \texttt{\color{OliveGreen}WHERE} condition to the previous device selection query.\\



%start of iteraitoin 3
\pagebreak
		\subsubsection{Iteration 3 - Improving Responder Alert}
		\paragraph{Aim}
This iteration addresses the issue of our system currently only contacting one person at a time when searching for an emergency responder. With the timeout of the accept response by the contacted user being (at minimum) 30 seconds, the time between the first person contacted and eventually finding an available responder could be many minutes (which would eat into the 8 minute ambulance response time [30]).\\

This iteration aims to reduce this concern by adding a parallel search (in the same vein as the previous iteration) so that multiple responders can be contacted simultaneously increasing the likelihood of contacting someone who is available and reducing the responder response time.\\

		\paragraph{Storyboard}
		This storyboard visualises the intended functionality of the system.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration3/Storyboard - Iteration 2 - 1"}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration3/Storyboard - Iteration 2 - 2"}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration3/Storyboard - Iteration 2 - 3"}
	\end{figure}
	\begin{enumerate}
  		\item Multiple parallel searches for responders are started. Each stream selects from the same group of responders (without overlap).
  		\item The responder is given the opportunity to accept or decline the request (as in the previous iteration).
  		\item If they accept the request, they go off to help at the emergency. If they decline, the system contacts the next closest person to the emergency. Subsequent responders are also given the option to accept or decline.
  		\item This continues until a user says they are able to help or the request is cancelled/resolved by the dispatcher.
	\end{enumerate}
	This will help our system to more quickly find an available responder to attend an incident as we are benefiting from the effects of parallelization. It also allows us to send multiple responders to an incident so that if one was delayed on route there is already another responder who is actively attending. It would also allow the dispatcher to specify that they required many responders, for example a large scale emergency with many casualties.\\
	
	\pagebreak
	\paragraph{Parallel Searches}
\begin{wrapfigure}{r}{0.4\textwidth}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{"Iteration3/parallelization_of_search (4) (1)"}
  \end{center}
  \vspace{-250pt}
\end{wrapfigure}
	In order to implement the ability to perform parallel searches for responders we need to first look at the way in which the process for searching and selecting a responder is done. Below is a flowchart showing the basic layout of searching for a responder on the server side. We can see how the workflow lends itself to parallelization as there is a single flow from top to bottom which, once started, has no outside influences and will terminate by itself once a responder has been found or there are no more suitable responders to ask (based off the criteria in the previous iteration).\\

This means that with some refactoring we can set up multiple runs of this search alongside each other with little effort.\\

\pagebreak
	\begin{figure}[H]
		\centering
		\vspace{-80pt}
		\includegraphics[width=0.9\textwidth]{"Iteration3/parallelization_of_search (2) (1)"}
	\end{figure}
The above diagram shows how, after the number of required responders is specified, the searches can be run independently of each other and terminate on their own.
Implementing this would require extracting the initial setup of the search (passing the details such as the location) and calling a overseeing method which then start the required number of parallel searches. As each search is using a common database for selecting and marking users decisions (using the methods described in the previous iteration) this should eliminate the possibility of a parallel search selecting a responder for an event who has already been contacted.\\

\pagebreak
\begin{wrapfigure}{l}{0.4\textwidth}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{"Iteration3/parallelization_of_search (3) (1)"}
  \end{center}
\end{wrapfigure}
We do need to take measures to prevent some problems. The first being that we need to ensure that when parallel searches come to select a new responder to contact they do not select the same responder in the time between one search selecting the user and marking them as available or unavailable. The red box on the below diagram illustrates the current area of overlap between a responder being selected by a search and that responder being marked by that search (i.e. the area where two searches could select the same responder to contact).\\

To counter this we need to implement two things, first we need to mark a chosen responder as soon as they have been selected. Currently a responder is only marked as chosen after they have accepted or declined (minimum of 30 seconds) so if we were to leave it like this any parallel searches would have to wait on this mark to continue.\\

This can be implemented right after the selection has been made and before the notification is sent to the user minimizing the time that a selected user is not marked. We could add another table in the database for ‘SelectedResponders’ however we already have a system in place to differentiate between selected and non-selected responders (the accepted/declined mark). We could simply mark a responder as ‘declined’ as soon as we have selected them as this does not impact the flow from that point on (contacting the user and obtaining a response) and then change this mark to ‘Accepted’ if they accept. If they decline or the operation time out then we have already marked them as ‘Declined’ and simply return to the start of the search process.\\

In order to further reduce same responder selection we can close the window for searches to overlap completely by locking the database table while one search is selecting a responder until they have marked them as selected. This would mean that two parallel searches that ran at exactly the same time would not be able to access the database table and so one would have to wait until the other finished and unlocked the table before continuing. Introducing a lock also introduces a form of staggered startup so that at the initial responder selection for each parallel search there would not be an occasion where they would both be able to select the same initial user to start as they could be running very close (time wise) together and have a greater chance of overlapping.\\

\pagebreak
\begin{wrapfigure}{l}{0.4\textwidth}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{"Iteration3/parallelization_of_search (4) (2)"}
  \end{center}
  \vspace{-250pt}
\end{wrapfigure}
The diagram left shows the revised series of stages for the search to complete and displays the time that the database table would need to be locked for. As you can see it is substantially less than the overlap time from before and both of the operations inside the lock should be completed very swiftly. As soon as the lock is lifted any other searches looking for a responder are free to search and the responder selected by the search that owned the lock has marked that responder so no other searches will select it.\\

This should fix all of the problems when implementing this feature and allow us to speed up the selection process and allow multiple responders to be contacted.\\

\pagebreak
\paragraph{Usage}
This feature will be used in two distinct ways, firstly it gives the dispatcher the ability to request more assistance for larger emergencies in the form of more responders being directed to the site. A use case for this could be a car crash with multiple injured people where one responder would be quickly overwhelmed and unable to help more than a few people. This request will be part of the API and can be built into the dispatchers system to increase the number of responders as they see appropriate.\\

The system should also be used and, by default, contact two people for each emergency. This would mean that more potential responders are contacted faster than in the old system (through the parallelization) and it should end with two responders being sent to the incident. This is useful as it increases the chance that one of them arrives before the paramedics (for example one might be stuck due to unforeseen circumstances) and the risk of the responders not getting there is halved (split between the two). \\

We feel that it is acceptable to send two responders to an incident by default as it firstly decreases the risk that the responder does not arrive. It also means that, if both responders arrive, they can help each other with the casualty until the paramedics relieve them. We feel that sending two responders to the same incident is acceptable and that they should not mind not being the only one sent as the health of the casualty should take priority.\\



%start of iteraitoin 3
\pagebreak
		\subsubsection{Iteration 4 - Context of the emergency}
		\paragraph{Aim}
This iteration addresses the issue of the responders currently going out to an emergency blind to what they may encounter. This iteration will address this by supplying relevant information to the responder when they are alerted to an incident. This information will help them identify the patient when the arrive on site and alert them to any critical information that may be of help.\\

		\paragraph{Storyboard}
		This storyboard visualises the intended functionality of the system.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration4/Storyboard - Iteration 3 - 1"}
	\end{figure}
	\begin{figure}[H]
		\centering
		\vspace{-20pt}
		\includegraphics[width=1\textwidth]{"Iteration4/Storyboard - Iteration 3 - 2"}
	\end{figure}
	\begin{enumerate}
  		\item A responder is contacted about an emergency situation near by.
  		\item The message contains details about what kind of emergency situation they are being asked to help at as well as relevant details of the casualty (if any are available).
  		\item If they accept the request, they go off to help at the emergency. If they decline, the system contacts the next closest person to the emergency.
  		\item After accepting they make their way to the emergency knowing what to expect on the scene and being aware of any special precautions they need to take when dealing with the patient.

	\end{enumerate}
This will help the responders to emergency situations mentally prepare before they arrive on scene. Information provided to them will alert them to the type of emergency they are attending, allowing them to think about potential first aid that they may need to give. It may also help them to identify casualties better in certain situations, being given a brief description of the casualty (e.g. Sex, Age) for situations where there are multiple casualties (allowing them to go directly to the more serious one).

\paragraph{Information}
When a phone call is received by the emergency services there is a standard set of questions (for a medical emergency) that will be asked by the call taker. The first set of questions, used to ascertain what help is required, are the location of the emergency, the phone number the caller is using and exactly what has happened regarding the emergency call [31]. Once this information is received the call taker is able to send help. Then the call taker will ask the caller for any additional information such as: the patient's age, gender and medical history. Whether the patient is awake/conscious, breathing and if there is any serious bleeding or chest pain; and Details of the injury and how it happened [31].\\

Out of this information there are two distinct sections. The standard information gained from the questions required before the emergency services are dispatched and the extra information which may or may not be given for a call (dependant on the circumstances). This means that we can rely on the ability to provide some extra information to the emergency responder, such as location (which is already being sent) and a description of exactly what happened. However, in some cases we are able to send additional information as detailed above to help the first responder.\\

For some of this information we need to be mindful of the data protection of the individual in concern and any policies that may be in place by the organizations implementing our system. The London Ambulance Service’s policy on disclosure to third parties is “We will not disclose your information to third parties (for instance outside the NHS) without your permission unless there are exceptional circumstances” [32]. This would mean that without modifications to their data protection policies to either include first responders or class them under the ‘exceptional circumstances’, it is unlikely that they would make use of the extra information sending capability of our system. However, sending the description of the incident should be acceptable as this would contain no personal information about the casualty. We have decided to implement the ability to send the additional information in our system for potential future use by the organizations in question after a review of their policies.\\

A breakdown of the extra information that can be included in a request for a first responder is as follows:\\
\textbf{Mandatory information:}
\begin{itemize}
\item Description of the incident
\end{itemize}
\textbf{Voluntary information:}
\begin{itemize}
\item Patient age
\item Patient gender
\item Relevant medical history
\item Current state of the patient (awake/conscious)
\item Breathing
\item Serious bleeding and/or chest pain
\item Additional details of the injury and how it happened.
\end{itemize}
The mandatory information should be included in all messages sent to first responders as this information is always given to the call taker of an emergency call. The voluntary information may be given in full or part and as such should be included if applicable (and depending on the data protection policies involved).

\paragraph{Notification Details}
In order to send this new information to the first responders we can utilize the payload feature of GCM’s messages again. The modifications would only need to be to the \texttt{\color{OliveGreen}‘new\_emergency’} messages and there should be a field added for each section of additional information that is to be sent. The structure of the message data should be as follows:
\begin{lstlisting}
...
"data":
      {
          "message_type":"new_emergency",
          "longitude":"VALUE",
          "latitude":"VALUE",
          "incidentDescription":"VALUE",
		  //optional after here
          "age":"VALUE",
          "gender":"VALUE",
          "patientState":"VALUE",
          "breathing":"VALUE",
          "bleeding":"VALUE",
          "chestPain":"VALUE",
          "medicalHistory":"VALUE",
          "additionalDetails":"VALUE"
      }
...
\end{lstlisting}
The \texttt{\color{OliveGreen}“incidentDescription”} field should be present in all \texttt{\color{OliveGreen}‘new\_emergency’} messages from now on and contain a text description of the incident taken from the call takers notes while answering the call. Any optional fields should be not included in the message if no message data is present for them and then parsed in the app to determine which fields to display to the user.\\

The datatype of the optional fields are as follows, though all field values are sent as strings the data in them should be in a standard format to be understood by the app:
\begin{table}[h]
\begin{tabular}{|l|l|l|}
\hline
\textbf{Field Name} & \textbf{Data Type}       & \textbf{Example Data}                 \\ \hline
age                 & Integer (1-3 characters) & "77"                                  \\ \hline
gender              & Single Character         & "M" or "F"                            \\ \hline
patientState        & Single Character         & "C" or "U" (conscious\& unconscious)  \\ \hline
breathing           & Single Character         & "T" or "F" (true or false)            \\ \hline
bleeding            & Single Character         & "T" or "F" (true or false)            \\ \hline
chestPain           & Single Character         & "T" or "F" (true or false)            \\ \hline
medicalHistory      & String                   & "Asmatic, previous heart attack"      \\ \hline
additionalDetails   & String                   & "Casualty fell down flight of stairs" \\ \hline
\end{tabular}
\end{table}
Some of the data has been compressed into single characters to be sent over the message, this is to help maximize the available space of the GCM payload (which is limited to 4kb) for other fields which may contain long strings. Fields with a single character will have a limited pool of available values which can be parsed on the app to display a more meaningful message to the user. \\

\paragraph{App CPR Pane}
This is the prototype for the additional details display pane. This can be accessed from the home page of the app by pressing on the location details covering the lower third of the pane. We decided to use this as the doorway to accessing the additional information rather than a button because we are already dealing with limited space on the menu bar below the map. We wanted it to be accessible while the accept/decline buttons are visible (which cover the menu bar) and we feel that it is an intuitive way to obtain more information. Many apps utilize the ‘click to explore’ methodology and this is what users will be expecting from their previous experiences.\\

The details pane shown below illustrates how an emergency notification with only the essential information will be shown to a user. We maintained the address at the top so that if the user was making their way to the location they would not have to switch back to the previous pane to see the address. The incident description is also present which gives the user some information on the incident and what they might expect.\\

This pane also has a prominent back button which the user can use to move to the homepage of the app.\\
	\begin{figure}[H]
		\centering
		\vspace{-20pt}
		\includegraphics[width=1\textwidth]{"Iteration4/Additional Details - 1"}
	\end{figure}
	
A more detailed view is shown in the image below, here much more information has been provided to the user. The information is grouped into common sections and any single characters from the message data have been expanded into their respective words/phrases. Any omitted information is not shown to the user, for example the \texttt{\color{OliveGreen}‘chestPain’} field is not applicable here as the patient is unconscious and so it was not sent in the message and the app does not display anything regarding this piece of information.\\

This pane is scrollable so that if a longer description is provided, or in future versions more information is available to be sent, it will all fit on this pane and the user can easily scroll to the information they need.\\

	\begin{figure}[H]
		\centering
		\vspace{-20pt}
		\includegraphics[width=0.6\textwidth]{"Iteration4/Additional Details - 2"}
	\end{figure}
	
	
%start of iteraitoin 5
\pagebreak
		\subsubsection{Iteration 5 - User Preferences}
		\paragraph{Aim}
		This iteration gives the user more flexibility and control over various features that the CPR system offers. The user should be able to change preferences such as when they can be contacted or how they are alerted allowing them to personalise the service to fit into their lifestyle.
		
		\paragraph{Storyboard}
		This storyboard visualises the intended functionality of the system.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration5/Storyboard - Iteration 5 - 1"}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration5/Storyboard - Iteration 5 - 2"}
		\vspace{10pt}
	\end{figure}
	\begin{enumerate}
  		\item A responder wishes to personalise the app to better suit their lifestyle.
  		\item The responder can find a variety of options inside a settings menu of the app.

	\end{enumerate}
	This will help the responders to emergency to personalise how they are contacted to fit into their lifestyle. There should be options to change notification alerts, change how often they can be contacted, set hours they can be contacted along with more. This means that the user has control over when it's convenient for them to be contacted which makes it more likely they will keep using the service improving its efficiency and user base.\\

The settings menu of the app will be accessible from the default OS settings menu. Here there will be an app-specific pane which will grant access to the settings menu for our app. This means that we do not have to implement an icon on the main app page which would take up space from more important features. Also, the user is unlikely to be regularly changing the settings for this app so they are not needed to accessible from the app itself.

\paragraph{'Do Not Disturb' for a period of time}
We feel that the option to ‘unregister’ from being contacted for a period of time is one which users would appreciate and use. Allowing the user to set a length of time in which they do not wish to be contacted will help to keep the retention rate of those using the app high. If this is not implemented then people may look to unregister from the service and then re-register later increasing the chance that some never re-register because it is too much hassle.\\

This feature could be used in a variety of situations such as a responder is going on holiday for a week or two, they are physically unable to help for a while (for example a broken foot) or other personal matters which mean they are not in a position to help. Whatever the reason our app will give the user the ability to specify a period of time that they are not to be contacted in.

\pagebreak
\subparagraph{App Design}
Our settings menu should clearly show a category for allowing the user to say they are unavailable for a time. From here they should be taken to a new settings pane in which they are able to set the amount of time they are unavailable for. \\

	\begin{figure}[H]
		\centering
		\vspace{-20pt}
		\includegraphics[width=1\textwidth]{"Iteration5/Storyboard - Iteration 6 - 1"}
	\end{figure}
This pane allows them to select a date until which they do not wish to be contacted, at the bottom the time until the selected date is displayed in days, months and years and there is a ‘save’ button at the bottom. Once the save button is pressed the date is uploaded to our servers via the GCM upstream messages service and is then stored in our database.
\subparagraph{Server Modifications}
In order to provide this feature our search algorithm will need to be modified to check if a ‘do not contact’ date has been set. There are three possible genres of value for this field:
\begin{itemize}
\item Null (i.e. not set)
\item A date in the future
\item A date in the present or past
\end{itemize}
If an individual's records have no date set then the individual is available for contacting and the algorithm proceeds as normal. If there is a date present and it is in the future then this individual is ignored by the algorithm. If there is a date and it is in the present (current day) or the past then the algorithm should replace this value with null and then proceed with the individual as normal.\\

This feature will provide little extra overhead to the server as there will be only one extra comparison (between the saved and current date) which will be run if a user is selected as a candidate to be contacted.

\subparagraph{Database Modifications}
This feature is tied to an individual rather than a device - if a responder selects a do not disturb date on one device, we want to ignore them completely (on all devices) until that date.\\

As a result, this feature is trivial from a data perspective: it is simply represented by a new \texttt{\color{OliveGreen}DoNotDisturbUntil} field in the \texttt{\color{OliveGreen}Responders} table. Minute precision is provided by SQL Server’s \texttt{\color{OliveGreen}smalldatetime} type, and the column will default to \texttt{\color{OliveGreen}null}.

	\begin{figure}[H]
		\centering
		\includegraphics[width=0.5\textwidth]{"Iteration5/iteration-5-dnd"}
	\end{figure}

\paragraph{Respecting system alert preferences}
We have decided to include an option in the setting menu which will allow the user to toggle whether the app should respect the operating system’s alert preferences. This controls whether the app should be silenced by the device’s ‘silent’ or ‘do not disturb’ modes.\\

We have decided to include this toggle for situations where the user does not wish to unregister for a period of time, but does not wish for the alert to make a sound and feels they would be able to notice an alert regardless. However, we have decided that by default this feature is disabled so that the app will ignore the system alert preferences.\\

The reasoning for this stems from the nature of the app: in an emergency situation every second is vital and a user not realising they have a notification would mean that the search would pause for 30 seconds until the alert is automatically declined. We also believe that users are of a mind that the importance of potentially saving a life is above any inconvenience caused by the users phone going off. Also the frequency of messages from this app is likely to be quite low from an individual's perspective so it is unlikely that this will prove to be a common issue for them.

\pagebreak
\subparagraph{App design}
Our settings menu should clearly show a category for allowing the user to say they are unavailable for a time. From here they should be taken to a new settings pane in which they are able to set the amount of time they are unavailable for.\\

	\begin{figure}[H]
		\centering
		\vspace{-20pt}
		\includegraphics[width=1\textwidth]{"Iteration5/Storyboard - Iteration 6 - 2"}
	\end{figure}

Here you can see that the effect of toggling this button is clearly defined to the user and it is explained that the default setting is that its turned on and why that is. Toggling this button will change how the notifications created when a new message is received from GCM are categorized.\\

Different categories determine if the notification is affected by Androids ‘Priority Mode’ and therefore if they are silenced. Setting the notification to an “ALARM” type [56] will mean the sound plays regardless of the system state. This settings value will need to be stored locally and then used when building the notifications for an alert.

\paragraph{Let the user specify the hours they will be asleep and thus unavailable}
This option allows the user to set a time when they are likely to be asleep and therefore do not wish to be contacted about any emergencies. There is also an option for users who do not mind being contacted at all hours. When toggled to ‘ON’ the rest of the settings pane is greyed out and unavailable to change.
\pagebreak
\subparagraph{App Design}
The settings pane for this feature allows the user to enter a start and end time during which they are usually asleep. This will then be sent to our server when the ‘save’ button is pressed and exclude this user between the two times. By default the app is set to “allow contact at all times” because we feel that it is best to let the user select the appropriate times for themselves. Also the frequency of messages from this app is likely to be quite low from an individual's perspective so it is unlikely that being woken in the night by this app will be a common problem for an individual.\\
	\begin{figure}[H]
		\centering
		\vspace{-20pt}
		\includegraphics[width=1\textwidth]{"Iteration5/Storyboard - Iteration 6 - 3"}
		\vspace{-20pt}
	\end{figure}
	

When the save button is clicked the start and end date are both sent to our server via GCM’s upstream service and stored on our database. If “allow contact at all times” is set to ‘ON’, the start and end times are set to midnight, which is interpreted by the server as no sleep period.

\subparagraph{Server Modifications}
Our search algorithm will need to be modified so that once an individual is selected there is a check that the current time is not between the start and end of the ‘sleep’ times. This feature will provide little extra overhead to the server as there will be only one extra comparison (between the sleep times and current time) which will only be run if an individual is selected as a candidate to be contacted.
\subparagraph{Database Modifications}
Similarly to the do not disturb feature, the sleep times are tied to the responder rather than their individual devices, so the data is places in the \texttt{\color{OliveGreen}Responders} table. It will be contained in two fields, \texttt{\color{OliveGreen}SleepBegin} and \texttt{\color{OliveGreen}SleepEnd}, which will both default to \texttt{\color{OliveGreen}null}, indicating no times configured. Regarding the type, we only need accuracy to the minute, and no date component is required (as sleep reoccurs every night). SQL Server doesn’t have a perfect match, however the closest is \texttt{\color{OliveGreen}time(0)} which can handle a seconds component as well - it is more accurate than required.
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.5\textwidth]{"Iteration5/iteration-5-sleep"}
	\end{figure}

\pagebreak
This leaves the database design at the end of this iteration as follows:
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{"Iteration5/iteration-5-end"}
	\end{figure}

	
%start of iteraitoin 6
\pagebreak
		\subsubsection{Iteration 6 - Improving User Selection}
		\paragraph{Aim}
		As it stands, users are selected based on their straight line distance from the location of the incident. This works at a basic level, but is suboptimal and problematic for several reasons.
		
		\paragraph{Problems}
		\subparagraph{Impassable Terrain}
		Not all distances are equally quick to cover. A 200m journey along a flat road is relatively quick, whereas a shorter journey up a steep hill - or indeed over or up a cliff - poses more of a problem for responders. This will either substantially slow the responder down while they find a route, or mean they reject the request for assistance.
		\subparagraph{Mode of Transport}
		Similarly the current selection mechanism doesn’t take into account the rate at which responders can cover the distance to the emergency. Those in cars will usually move quicker, but traffic conditions will influence this, so it cannot be universally regarded as superior. In addition, the selection algorithm is only given positions of responders - it is unaware of their mode of transport, whether they’re moving towards or away from an incident etc.
		\subparagraph{Elevation}
		This is a more subtle problem, but it could cause major delays in built up areas. The current algorithm works in two-dimensional space, assuming two equal distances are equally quick to traverse. As a result, cities containing lots of tall buildings with subtle access points pose a problem. Someone initially appearing to be closer may take longer to reach an emergency, as they have to go further away to reach an escalator or lift. This problem will also emerge whenever paths cross or overlap, such as when a road crosses a river, built over a path along the bank.

		\paragraph{Solutions}
		There are some solutions to all of the issues described above, however before they are considered, so must be performance. Currently, straight line distance is calculated by the database engine using the \texttt{\color{OliveGreen}STDistance} function. As a result, it is incredibly fast and so conceivable to run on the latest data from every responder for every incident. More involved solutions, like route-finding, cannot be done in this way. They require significant overhead and so the speed of operation must be considered.\\

The issue of impassable terrain can be overcome by using a mapping service (such as Google Maps or Ordinance Survey) to get details of terrain and routes. If the surface profile between the responder and the incident is relatively flat, the straight line distance becomes a more effective measure of travel time. Likewise, if there is a path or road that starts and ends near the points, it suggests they are reasonably accessible to each other.\\

The next step up from this is doing a full search between each responder and the incident. While this would give the most accurate result, and could even be used to guide responders to incidents, it is also very inefficient, even when highly parallelised. As a result, it would have to be used with another technique, possibly straight line distance. In this case, straight line distance would be used to filter out those who are simply too far away to arrive within the 8 minute window. Using the average walking speed of 3.1 mph [61], and assuming this is the slowest any responder will travel at (a safe approximation, given most responders will walk briskly or run), the maximum straight line distance any potential responder should be from an incident is 665m. Therefore, \texttt{\color{OliveGreen}STDistance} can be used to select all responders within this radius of an incident, and then do run a search algorithm on them. If this proves to be too much in congested areas, even after optimising performance (in theory every responder’s search could be run in parallel), the limit would have to be lowered.\\

However, it is important to realise that there are no universal solutions to the issues described above. It is impossible to keep a constant record of whether a responder is on foot or bicycle, in a car or on a bus that is travelling a set route - which may happen to deviate away from the incident in the future. It would be foolish to select someone based on a footpath between them and the incident, when they are in a car.\\

After a fair amount of thought and brainstorming, it became evident that the best overall solution is to use the historical data available to make better decisions. People’s lives are normally full of patterns, which can be exploited to our advantage. This, combined with using the last few locations of a person to calculate their speed - and therefore likely mode of transport (with on foot being a good assumption if no movement), means it should be possible to give accurate predictions of where each person will be at a given time. Using this data, the system will be able to answer questions like ‘Who will be nearest to this incident within the next minute?’, compensating for travel distance as the time increases. It will be a compromise between sending someone further away sooner, and telling someone currently further away who we believe is travelling towards the emergency.\\

Of course, in practice the system would always choose someone closer to the incident now, as it is safer, however specifying such a system is beyond the scope of this project. Although a very interesting mini-project, a large testing effort would be required to design it, so our specification will remain with eliminating those too far away using straight line distance, before running search on the remaining ones using walking as the mode of transport.

\end{document}
